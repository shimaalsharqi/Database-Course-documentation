Database Course Documentation

1. Comparison Between Flat File Systems and Relational Databases

Flat File Systems and Relational Databases are both used for storing data, but they differ greatly in structure, redundancy handling, relationships, usage, and limitations. The following sections provide a detailed comparison.

Structure

Flat File Systems:
Store data in simple text-based formats such as CSV or TXT. Records are listed sequentially, and there is no concept of tables, schemas, or defined relationships.

Relational Databases:
Organize data into structured tables (rows and columns). They use primary keys and foreign keys to define relationships and enforce data integrity.

Data Redundancy

Flat File Systems:
High redundancy because the same data may be repeated across multiple files. There is no built-in mechanism to avoid duplication.

Relational Databases:
Redundancy is reduced through normalization techniques, which split data into related tables to avoid duplication and maintain consistency.

Relationships

Flat File Systems:
Relationships are either implicit or manually duplicated. There is no formal system to link records between files.

Relational Databases:
Support explicit and well-defined relationships, such as:

One-to-One (1–1)

One-to-Many (1–M)

Many-to-Many (M–M)
These are enforced using primary and foreign keys.

Example Usage

Flat File Systems:
Used for simple or temporary data storage such as:

CSV lists

Log files

Small datasets that do not require complex querying

Relational Databases:
Used for large-scale systems that require structured data and complex operations, such as:

Student registration systems

Banking systems

E-commerce applications

Enterprise applications and web systems

Drawbacks

Flat File Systems:

Hard to maintain

No support for complex queries

Weak security

Higher chance of data inconsistency or corruption

Relational Databases:

More complex to design and manage

May require licensing costs

Require more storage and processing resources

Need regular maintenance

Roles in a Database System
| Role                | Description                                                                                           |
|---------------------|-------------------------------------------------------------------------------------------------------|
| System Analyst      | Responsible for gathering business requirements and analyzing organizational needs. Designs processes |
|                     | and ensures that the database system aligns with business goals.                                      |
| Database Designer   | Creates the logical and physical database models. Applies normalization and defines entities,         |
|                     | attributes, relationships, and constraints to ensure proper structure.                                |
| Database Developer  | Develops SQL queries, stored procedures, triggers, and views. Ensures efficient data manipulation,    |
|                     | integration, and supports application requirements.                                                   |
| DBA (Administrator) | Manages database performance, security, backups, and recovery. Responsible for installation, tuning,  |
|                     | user management, and ongoing maintenance of the DBMS.                                                 |
| Application Developer| Builds applications and interfaces that interact with the database. Works with APIs, backend logic,  |
|                      | and ensures proper communication between the system and the DBMS.                                     |
| BI Developer        | Converts raw data into meaningful insights through reports, dashboards, and analytics. Performs ETL   |
|                     | processes and works with data warehouses and business intelligence tools.                             |



Types of Databases
1. Relational vs Non-Relational Databases
Relational Databases (RDBMS)

Relational databases store data in structured tables with rows and columns. They use SQL for querying and rely on primary and foreign keys to define relationships between tables.
Examples: MySQL, PostgreSQL, SQL Server, Oracle.
Best for: transactional systems, financial data, student systems, ERP, applications requiring strong consistency.

Non-Relational Databases (NoSQL)

Non-relational databases do not follow a strict tabular structure. They store data in flexible formats such as documents, key-value pairs, graphs, or wide-column stores.
Examples:

Document Store → MongoDB

Wide Column Store → Cassandra

Key-Value → Redis

Graph → Neo4j
Best for: large-scale distributed systems, real-time analytics, content management, IoT, social networks.

2. Centralized vs Distributed vs Cloud Databases
Centralized Database

A centralized database is stored and managed on a single central server. All users access the same location.
Advantages: easy to manage, strong security control, consistent data.
Disadvantages: single point of failure, performance bottlenecks.

Distributed Database

A distributed database stores data across multiple servers or locations. These servers work together but may be geographically separated.
Advantages: high availability, faster access for global users, fault tolerance.
Disadvantages: more complex management, data synchronization challenges.
Examples: Google Bigtable, Cassandra (distributed by design).

Cloud Databases

Hosted on cloud platforms and accessed over the internet. Managed by cloud providers such as Azure, AWS, or Google Cloud.
Advantages: scalable, pay-as-you-go pricing, automated backups and updates.
Disadvantages: depends on internet connectivity, potential privacy concerns.
Examples:

Azure SQL Database

Amazon RDS

Google Cloud Spanner
Use Case Examples
-----------------

| Scenario / System               | Best Database Type                 | Reason                                                         |
|---------------------------------|------------------------------------|----------------------------------------------------------------|
| Banking and financial systems   | Relational (RDBMS)                 | Requires strong consistency and ACID transactions              |
| Social media platforms          | Non-Relational (NoSQL – document/graph) | Handles massive unstructured data and high scalability |
| Global e-commerce platform      | Distributed or Cloud Database      | High availability and fast access for users worldwide          |
| IoT sensor data                 | NoSQL (wide column or key-value)   | Supports rapid data ingestion from large numbers of devices    |
| University or HR system         | Relational Database                | Structured data with well-defined relationships                |
| Analytics and dashboards        | Cloud Database or Data Warehouse   | Designed for large-scale processing and flexible querying      |


Cloud Storage and Databases
1. What is Cloud Storage and how does it relate to databases?

Cloud storage is a service that allows users and organizations to store data on remote servers hosted on the internet rather than on local physical devices. These servers are managed by cloud providers such as Microsoft Azure, Amazon Web Services (AWS), or Google Cloud.

Cloud storage relates to databases because many modern database systems run directly in the cloud. Instead of installing a database on a local server, organizations can use cloud-hosted databases that store their data in cloud infrastructure.
Cloud databases provide scalability, global accessibility, automated maintenance, and integration with cloud applications.

Examples of cloud-based databases include:

Azure SQL Database (Microsoft)

Amazon RDS (AWS)

Google Cloud Spanner (Google Cloud)

2. Advantages of Cloud-Based Databases
✓ Scalability

Databases can scale up or down automatically based on workload, allowing businesses to handle more users or data without upgrading hardware.

✓ Reduced Maintenance

The cloud provider handles updates, patches, backups, and infrastructure management, reducing the workload on IT teams.

✓ High Availability

Cloud databases run across multiple servers and regions, offering uptime guarantees and minimizing downtime.

✓ Cost Efficiency (Pay-as-you-go)

Organizations only pay for the storage and processing they use. No need to purchase expensive physical servers.

✓ Accessibility

Data can be accessed securely from anywhere with an internet connection, making remote work and global systems easier.

✓ Built-in Security Features

Cloud providers offer encryption, access control, identity management, and compliance certifications.

3. Disadvantages of Cloud-Based Databases
✗ Internet Dependency

If the internet connection is slow or down, access to the cloud database becomes limited or impossible.

✗ Potential Security or Privacy Concerns

Although security is strong, some organizations worry about storing sensitive data outside their own physical environment.

✗ Higher Long-Term Costs

For very large workloads, ongoing cloud usage costs may become higher compared to owning private infrastructure.

✗ Limited Control Over Infrastructure

Users cannot manage the underlying hardware and sometimes cannot customize certain configurations.

1. What is a Database Engine?

A Database Engine is the core software component of a database system that handles the storage, retrieval, and updating of data. It processes SQL queries, manages transactions, enforces data integrity, and ensures efficient performance. Essentially, it is the “heart” of a database system that executes all database operations.

2. Examples of Database Engines

Some widely used database engines include:

SQL Server (Microsoft)

MySQL (Oracle)

Oracle Database

PostgreSQL

Each engine has its own architecture and optimizations, but they all follow the principles of database management.
Database Languages
------------------

Database engines use different languages or SQL dialects to define, query, and manipulate data. Some examples:

1. SQL Server
   - Language: T-SQL (Transact-SQL)
   - Notes: Extended SQL with procedural programming features like stored procedures, triggers, and functions.

2. Oracle Database
   - Language: PL/SQL
   - Notes: Procedural extension of SQL supporting triggers, procedures, and complex logic.

3. MySQL
   - Language: ANSI SQL (with some extensions)
   - Notes: Standard SQL compliant with minor engine-specific extensions.

4. PostgreSQL
   - Language: PL/pgSQL
   - Notes: ANSI SQL compliant with procedural extensions, supports stored procedures and functions.

Relationship Between Engine and Language:
- The database engine determines which SQL dialect is supported.
- Basic ANSI SQL is portable across engines.
- Proprietary extensions (T-SQL, PL/SQL, PL/pgSQL) are engine-specific.
- Migration of advanced procedural code between engines requires adaptation.
4. Relationship Between Engine and Language

The database engine determines which SQL dialect or extensions are supported.

While all engines generally support ANSI SQL (standard SQL), each engine adds proprietary extensions to handle advanced features like stored procedures, triggers, and transaction control.

Therefore, SQL code written for one engine may need modification to run on another engine, especially if it uses proprietary features.

5. Can One Language Work Across Different Engines?

ANSI SQL is portable and works across most relational databases for basic queries.

However, engine-specific features (like T-SQL for SQL Server or PL/SQL for Oracle) are not directly portable.

Migrating SQL code between engines often requires adapting stored procedures, triggers, functions, and certain data types.

Summary: Basic SQL is largely cross-platform, but advanced procedural code is engine-dependent.
1. Is it possible to migrate a database between engines?
-------------------------------------------------------
Yes, it is possible to migrate a database from one engine to another, for example:
- SQL Server → MySQL
- Oracle → PostgreSQL
However, the process is not always straightforward because different engines have their own SQL dialects, features, and storage mechanisms.

2. Challenges of engine-to-engine migration
-------------------------------------------
- **SQL Dialect Differences:** T-SQL (SQL Server) or PL/SQL (Oracle) may not run directly in MySQL or PostgreSQL.
- **Stored Procedures and Functions:** Proprietary procedural code often needs rewriting for the target engine.
- **Triggers:** Engine-specific triggers may require adjustment or reimplementation.
- **Data Types:** Some data types in the source engine may not exist in the target engine, requiring mapping.
- **Indexes and Constraints:** Differences in indexing and constraint implementation can affect performance and integrity.
- **Transactions and Concurrency Control:** Variations in transaction handling and isolation levels may need attention.
- **Data Size and Compatibility:** Large databases may require careful planning and testing to prevent data loss or corruption.

3. Considerations before transferring
--------------------------------------
- **Data Type Mapping:** Ensure all source data types have compatible types in the target engine.
- **Stored Procedures & Triggers:** Analyze and rewrite any engine-specific procedural code.
- **Views and Queries:** Check that complex queries and views work as expected in the new engine.
- **Testing:** Perform extensive testing in a staging environment before full migration.
- **Backup:** Always back up the original database before attempting migration.
- **Tools:** Use migration tools where available (e.g., MySQL Workbench, AWS DMS, Oracle SQL Developer) to simplify the process.



